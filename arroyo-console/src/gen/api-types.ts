/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/v1/connection_profiles": {
    /**
     * List all connection profiles 
     * @description List all connection profiles
     */
    get: operations["get_connection_profiles"];
    /**
     * Create connection profile 
     * @description Create connection profile
     */
    post: operations["create_connection_profile"];
  };
  "/v1/connection_tables": {
    /**
     * List all connection tables 
     * @description List all connection tables
     */
    get: operations["get_connection_tables"];
    /**
     * Create a new connection table 
     * @description Create a new connection table
     */
    post: operations["create_connection_table"];
  };
  "/v1/connection_tables/schemas/test": {
    /**
     * Test a Connection Schema 
     * @description Test a Connection Schema
     */
    post: operations["test_schema"];
  };
  "/v1/connection_tables/test": {
    /**
     * Test a Connection Table 
     * @description Test a Connection Table
     */
    post: operations["test_connection_table"];
  };
  "/v1/connection_tables/{id}": {
    /**
     * Delete a Connection Table 
     * @description Delete a Connection Table
     */
    delete: operations["delete_connection_table"];
  };
  "/v1/connectors": {
    /**
     * List all connectors 
     * @description List all connectors
     */
    get: operations["get_connectors"];
  };
  "/v1/jobs": {
    /**
     * Get all jobs 
     * @description Get all jobs
     */
    get: operations["get_jobs"];
  };
  "/v1/ping": {
    /**
     * Ping endpoint 
     * @description Ping endpoint
     */
    get: operations["ping"];
  };
  "/v1/pipelines": {
    /**
     * List all pipelines 
     * @description List all pipelines
     */
    get: operations["get_pipelines"];
    /**
     * Create a new pipeline 
     * @description Create a new pipeline
     * 
     * The API will create a single job for the pipeline.
     */
    post: operations["post_pipeline"];
  };
  "/v1/pipelines/validate_query": {
    /**
     * Get a pipeline graph 
     * @description Get a pipeline graph
     */
    post: operations["validate_query"];
  };
  "/v1/pipelines/{id}": {
    /**
     * Get a single pipeline 
     * @description Get a single pipeline
     */
    get: operations["get_pipeline"];
    /**
     * Delete a pipeline 
     * @description Delete a pipeline
     */
    delete: operations["delete_pipeline"];
    /**
     * Update a pipeline 
     * @description Update a pipeline
     */
    patch: operations["patch_pipeline"];
  };
  "/v1/pipelines/{id}/jobs": {
    /**
     * List a pipeline's jobs 
     * @description List a pipeline's jobs
     */
    get: operations["get_pipeline_jobs"];
  };
  "/v1/pipelines/{id}/restart": {
    /**
     * Restart a pipeline 
     * @description Restart a pipeline
     */
    post: operations["restart_pipeline"];
  };
  "/v1/pipelines/{pipeline_id}/jobs/{job_id}/checkpoints": {
    /**
     * List a job's checkpoints 
     * @description List a job's checkpoints
     */
    get: operations["get_job_checkpoints"];
  };
  "/v1/pipelines/{pipeline_id}/jobs/{job_id}/checkpoints/{epoch}/operator_checkpoint_groups": {
    /**
     * Get a checkpoint's details 
     * @description Get a checkpoint's details
     */
    get: operations["get_checkpoint_details"];
  };
  "/v1/pipelines/{pipeline_id}/jobs/{job_id}/errors": {
    /**
     * List a job's error messages 
     * @description List a job's error messages
     */
    get: operations["get_job_errors"];
  };
  "/v1/pipelines/{pipeline_id}/jobs/{job_id}/operator_metric_groups": {
    /**
     * Get a job's metrics 
     * @description Get a job's metrics
     */
    get: operations["get_operator_metric_groups"];
  };
  "/v1/pipelines/{pipeline_id}/jobs/{job_id}/output": {
    /**
     * Subscribe to a job's output 
     * @description Subscribe to a job's output
     */
    get: operations["get_job_output"];
  };
  "/v1/udfs": {
    /**
     * Get Global UDFs 
     * @description Get Global UDFs
     */
    get: operations["get_udfs"];
    /**
     * Create a global UDF 
     * @description Create a global UDF
     */
    post: operations["create_udf"];
  };
  "/v1/udfs/validate": {
    /**
     * Validate UDFs 
     * @description Validate UDFs
     */
    post: operations["validate_udf"];
  };
  "/v1/udfs/{id}": {
    /**
     * Delete UDF 
     * @description Delete UDF
     */
    delete: operations["delete_udf"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    AvroFormat: {
      confluentSchemaRegistry?: boolean;
      embeddedSchema?: boolean;
      intoUnstructuredJson?: boolean;
      readerSchema?: string;
    };
    Checkpoint: {
      backend: string;
      /** Format: int32 */
      epoch: number;
      /** Format: int64 */
      finishTime?: number | null;
      /** Format: int64 */
      startTime: number;
    };
    CheckpointCollection: {
      data: (components["schemas"]["Checkpoint"])[];
    };
    CheckpointEventSpan: {
      description: string;
      /** Format: int64 */
      finishTime: number;
      spanType: components["schemas"]["CheckpointSpanType"];
      /** Format: int64 */
      startTime: number;
    };
    /** @enum {string} */
    CheckpointSpanType: "alignment" | "sync" | "async" | "committing";
    ConnectionProfile: {
      config: unknown;
      connector: string;
      description: string;
      id: string;
      name: string;
    };
    ConnectionProfileCollection: {
      data: (components["schemas"]["ConnectionProfile"])[];
    };
    ConnectionProfilePost: {
      config: unknown;
      connector: string;
      name: string;
    };
    ConnectionSchema: {
      definition?: components["schemas"]["SchemaDefinition"] | null;
      fields: (components["schemas"]["SourceField"])[];
      format?: components["schemas"]["Format"] | null;
      framing?: components["schemas"]["Framing"] | null;
      structName?: string | null;
    };
    ConnectionTable: {
      config: unknown;
      connectionProfile?: components["schemas"]["ConnectionProfile"] | null;
      connector: string;
      /** Format: int32 */
      consumers: number;
      /** Format: int64 */
      createdAt: number;
      id: string;
      name: string;
      schema: components["schemas"]["ConnectionSchema"];
      tableType: components["schemas"]["ConnectionType"];
    };
    ConnectionTableCollection: {
      data: (components["schemas"]["ConnectionTable"])[];
      hasMore: boolean;
    };
    ConnectionTablePost: {
      config: unknown;
      connectionProfileId?: string | null;
      connector: string;
      name: string;
      schema?: components["schemas"]["ConnectionSchema"] | null;
    };
    /** @enum {string} */
    ConnectionType: "source" | "sink";
    Connector: {
      connectionConfig?: string | null;
      customSchemas: boolean;
      description: string;
      enabled: boolean;
      hidden: boolean;
      icon: string;
      id: string;
      name: string;
      sink: boolean;
      source: boolean;
      tableConfig: string;
      testing: boolean;
    };
    ConnectorCollection: {
      data: (components["schemas"]["Connector"])[];
    };
    FieldType: OneOf<[{
      primitive: components["schemas"]["PrimitiveType"];
    }, {
      struct: components["schemas"]["StructType"];
    }]>;
    Format: OneOf<[{
      json: components["schemas"]["JsonFormat"];
    }, {
      avro: components["schemas"]["AvroFormat"];
    }, {
      parquet: components["schemas"]["ParquetFormat"];
    }, {
      raw_string: components["schemas"]["RawStringFormat"];
    }]>;
    Framing: {
      method: components["schemas"]["FramingMethod"];
    };
    FramingMethod: {
      newline: components["schemas"]["NewlineDelimitedFraming"];
    };
    GlobalUdf: {
      /** Format: int64 */
      createdAt: number;
      definition: string;
      description?: string | null;
      id: string;
      name: string;
      prefix: string;
      /** Format: int64 */
      updatedAt: number;
    };
    GlobalUdfCollection: {
      data: (components["schemas"]["GlobalUdf"])[];
    };
    Job: {
      /** Format: int64 */
      createdAt: number;
      failureMessage?: string | null;
      /** Format: int64 */
      finishTime?: number | null;
      id: string;
      /** Format: int64 */
      runId: number;
      runningDesired: boolean;
      /** Format: int64 */
      startTime?: number | null;
      state: string;
      /** Format: int64 */
      tasks?: number | null;
    };
    JobCollection: {
      data: (components["schemas"]["Job"])[];
    };
    /** @enum {string} */
    JobLogLevel: "info" | "warn" | "error";
    JobLogMessage: {
      /** Format: int64 */
      createdAt: number;
      details: string;
      id: string;
      level: components["schemas"]["JobLogLevel"];
      message: string;
      operatorId?: string | null;
      /** Format: int64 */
      taskIndex?: number | null;
    };
    JobLogMessageCollection: {
      data: (components["schemas"]["JobLogMessage"])[];
      hasMore: boolean;
    };
    JsonFormat: {
      confluentSchemaRegistry?: boolean;
      debezium?: boolean;
      includeSchema?: boolean;
      timestampFormat?: components["schemas"]["TimestampFormat"];
      unstructured?: boolean;
    };
    Metric: {
      /** Format: int64 */
      time: number;
      /** Format: double */
      value: number;
    };
    MetricGroup: {
      name: components["schemas"]["MetricNames"];
      subtasks: (components["schemas"]["SubtaskMetrics"])[];
    };
    /** @enum {string} */
    MetricNames: "bytes_recv" | "bytes_sent" | "messages_recv" | "messages_sent" | "backpressure";
    NewlineDelimitedFraming: {
      /** Format: int64 */
      maxLineLength?: number | null;
    };
    OperatorCheckpointGroup: {
      /** Format: int64 */
      bytes: number;
      operatorId: string;
      subtasks: (components["schemas"]["SubtaskCheckpointGroup"])[];
    };
    OperatorCheckpointGroupCollection: {
      data: (components["schemas"]["OperatorCheckpointGroup"])[];
    };
    OperatorMetricGroup: {
      metricGroups: (components["schemas"]["MetricGroup"])[];
      operatorId: string;
    };
    OperatorMetricGroupCollection: {
      data: (components["schemas"]["OperatorMetricGroup"])[];
    };
    OutputData: {
      key: string;
      operatorId: string;
      /** Format: int64 */
      timestamp: number;
      value: string;
    };
    PaginationQueryParams: {
      /** Format: int32 */
      limit?: number | null;
      starting_after?: string | null;
    };
    ParquetFormat: Record<string, never>;
    Pipeline: {
      action?: components["schemas"]["StopType"] | null;
      actionInProgress: boolean;
      actionText: string;
      /** Format: int64 */
      checkpointIntervalMicros: number;
      /** Format: int64 */
      createdAt: number;
      graph: components["schemas"]["PipelineGraph"];
      id: string;
      name: string;
      preview: boolean;
      query: string;
      stop: components["schemas"]["StopType"];
      udfs: (components["schemas"]["Udf"])[];
    };
    PipelineCollection: {
      data: (components["schemas"]["Pipeline"])[];
      hasMore: boolean;
    };
    PipelineEdge: {
      destId: string;
      edgeType: string;
      keyType: string;
      srcId: string;
      valueType: string;
    };
    PipelineGraph: {
      edges: (components["schemas"]["PipelineEdge"])[];
      nodes: (components["schemas"]["PipelineNode"])[];
    };
    PipelineNode: {
      nodeId: string;
      operator: string;
      /** Format: int32 */
      parallelism: number;
    };
    PipelinePatch: {
      /** Format: int64 */
      checkpointIntervalMicros?: number | null;
      /** Format: int64 */
      parallelism?: number | null;
      stop?: components["schemas"]["StopType"] | null;
    };
    PipelinePost: {
      name: string;
      /** Format: int64 */
      parallelism: number;
      preview?: boolean | null;
      query: string;
      udfs?: (components["schemas"]["Udf"])[] | null;
    };
    PipelineRestart: {
      force?: boolean | null;
    };
    /** @enum {string} */
    PrimitiveType: "int32" | "int64" | "u_int32" | "u_int64" | "f32" | "f64" | "bool" | "string" | "bytes" | "unix_millis" | "unix_micros" | "unix_nanos" | "date_time" | "json";
    QueryValidationResult: {
      errors?: (string)[] | null;
      graph?: components["schemas"]["PipelineGraph"] | null;
    };
    RawStringFormat: Record<string, never>;
    SchemaDefinition: OneOf<[{
      json_schema: string;
    }, {
      protobuf_schema: string;
    }, {
      avro_schema: string;
    }, {
      raw_schema: string;
    }]>;
    SourceField: {
      fieldName: string;
      fieldType: components["schemas"]["SourceFieldType"];
      nullable: boolean;
    };
    SourceFieldType: {
      sqlName?: string | null;
      type: components["schemas"]["FieldType"];
    };
    /** @enum {string} */
    StopType: "none" | "checkpoint" | "graceful" | "immediate" | "force";
    StructType: {
      fields: (components["schemas"]["SourceField"])[];
      name?: string | null;
    };
    SubtaskCheckpointGroup: {
      /** Format: int64 */
      bytes: number;
      eventSpans: (components["schemas"]["CheckpointEventSpan"])[];
      /** Format: int32 */
      index: number;
    };
    SubtaskMetrics: {
      /** Format: int32 */
      index: number;
      metrics: (components["schemas"]["Metric"])[];
    };
    TestSourceMessage: {
      done: boolean;
      error: boolean;
      message: string;
    };
    /** @enum {string} */
    TimestampFormat: "rfc3339" | "unix_millis";
    Udf: {
      definition: string;
    };
    UdfPost: {
      definition: string;
      description?: string | null;
      prefix: string;
    };
    UdfValidationResult: {
      errors: (string)[];
      udfName?: string | null;
    };
    ValidateQueryPost: {
      query: string;
      udfs?: (components["schemas"]["Udf"])[] | null;
    };
    ValidateUdfPost: {
      definition: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  /**
   * List all connection profiles 
   * @description List all connection profiles
   */
  get_connection_profiles: {
    responses: {
      /** @description Got connections collection */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionProfileCollection"];
        };
      };
    };
  };
  /**
   * Create connection profile 
   * @description Create connection profile
   */
  create_connection_profile: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionProfilePost"];
      };
    };
    responses: {
      /** @description Created connection profile */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionProfile"];
        };
      };
    };
  };
  /**
   * List all connection tables 
   * @description List all connection tables
   */
  get_connection_tables: {
    parameters: {
      query?: {
        starting_after?: string | null;
        limit?: number | null;
      };
    };
    responses: {
      /** @description Got connection table collection */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionTableCollection"];
        };
      };
    };
  };
  /**
   * Create a new connection table 
   * @description Create a new connection table
   */
  create_connection_table: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionTablePost"];
      };
    };
    responses: {
      /** @description Created connection table */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectionTable"];
        };
      };
    };
  };
  /**
   * Test a Connection Schema 
   * @description Test a Connection Schema
   */
  test_schema: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionSchema"];
      };
    };
    responses: {
      /** @description Schema is valid */
      200: never;
    };
  };
  /**
   * Test a Connection Table 
   * @description Test a Connection Table
   */
  test_connection_table: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectionTablePost"];
      };
    };
    responses: {
      /** @description Job output as 'text/event-stream' */
      200: never;
    };
  };
  /**
   * Delete a Connection Table 
   * @description Delete a Connection Table
   */
  delete_connection_table: {
    parameters: {
      path: {
        /** @description Connection Table id */
        id: string;
      };
    };
    responses: {
      /** @description Deleted connection table */
      200: never;
    };
  };
  /**
   * List all connectors 
   * @description List all connectors
   */
  get_connectors: {
    responses: {
      /** @description Got connectors collection */
      200: {
        content: {
          "application/json": components["schemas"]["ConnectorCollection"];
        };
      };
    };
  };
  /**
   * Get all jobs 
   * @description Get all jobs
   */
  get_jobs: {
    responses: {
      /** @description Get all jobs */
      200: {
        content: {
          "application/json": components["schemas"]["JobCollection"];
        };
      };
    };
  };
  /**
   * Ping endpoint 
   * @description Ping endpoint
   */
  ping: {
    responses: {
      /** @description Ping endpoint */
      200: never;
    };
  };
  /**
   * List all pipelines 
   * @description List all pipelines
   */
  get_pipelines: {
    parameters: {
      query?: {
        starting_after?: string | null;
        limit?: number | null;
      };
    };
    responses: {
      /** @description Got pipelines collection */
      200: {
        content: {
          "application/json": components["schemas"]["PipelineCollection"];
        };
      };
    };
  };
  /**
   * Create a new pipeline 
   * @description Create a new pipeline
   * 
   * The API will create a single job for the pipeline.
   */
  post_pipeline: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PipelinePost"];
      };
    };
    responses: {
      /** @description Created pipeline and job */
      200: {
        content: {
          "application/json": components["schemas"]["Pipeline"];
        };
      };
    };
  };
  /**
   * Get a pipeline graph 
   * @description Get a pipeline graph
   */
  validate_query: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ValidateQueryPost"];
      };
    };
    responses: {
      /** @description Validated query */
      200: {
        content: {
          "application/json": components["schemas"]["QueryValidationResult"];
        };
      };
    };
  };
  /**
   * Get a single pipeline 
   * @description Get a single pipeline
   */
  get_pipeline: {
    parameters: {
      path: {
        /** @description Pipeline id */
        id: string;
      };
    };
    responses: {
      /** @description Got pipeline */
      200: {
        content: {
          "application/json": components["schemas"]["Pipeline"];
        };
      };
    };
  };
  /**
   * Delete a pipeline 
   * @description Delete a pipeline
   */
  delete_pipeline: {
    parameters: {
      path: {
        /** @description Pipeline id */
        id: string;
      };
    };
    responses: {
      /** @description Deleted pipeline */
      200: never;
    };
  };
  /**
   * Update a pipeline 
   * @description Update a pipeline
   */
  patch_pipeline: {
    parameters: {
      path: {
        /** @description Pipeline id */
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PipelinePatch"];
      };
    };
    responses: {
      /** @description Updated pipeline */
      200: {
        content: {
          "application/json": components["schemas"]["Pipeline"];
        };
      };
    };
  };
  /**
   * List a pipeline's jobs 
   * @description List a pipeline's jobs
   */
  get_pipeline_jobs: {
    parameters: {
      path: {
        /** @description Pipeline id */
        id: string;
      };
    };
    responses: {
      /** @description Got jobs collection */
      200: {
        content: {
          "application/json": components["schemas"]["JobCollection"];
        };
      };
    };
  };
  /**
   * Restart a pipeline 
   * @description Restart a pipeline
   */
  restart_pipeline: {
    parameters: {
      path: {
        /** @description Pipeline id */
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PipelineRestart"];
      };
    };
    responses: {
      /** @description Updated pipeline */
      200: {
        content: {
          "application/json": components["schemas"]["Pipeline"];
        };
      };
    };
  };
  /**
   * List a job's checkpoints 
   * @description List a job's checkpoints
   */
  get_job_checkpoints: {
    parameters: {
      path: {
        /** @description Pipeline id */
        pipeline_id: string;
        /** @description Job id */
        job_id: string;
      };
    };
    responses: {
      /** @description Got job's checkpoints */
      200: {
        content: {
          "application/json": components["schemas"]["CheckpointCollection"];
        };
      };
    };
  };
  /**
   * Get a checkpoint's details 
   * @description Get a checkpoint's details
   */
  get_checkpoint_details: {
    parameters: {
      path: {
        /** @description Pipeline id */
        pipeline_id: string;
        /** @description Job id */
        job_id: string;
        /** @description Epoch */
        epoch: number;
      };
    };
    responses: {
      /** @description Got checkpoint's details */
      200: {
        content: {
          "application/json": components["schemas"]["OperatorCheckpointGroupCollection"];
        };
      };
    };
  };
  /**
   * List a job's error messages 
   * @description List a job's error messages
   */
  get_job_errors: {
    parameters: {
      query?: {
        /** @description Starting after */
        starting_after?: string | null;
        /** @description Limit */
        limit?: number | null;
      };
      path: {
        /** @description Pipeline id */
        pipeline_id: string;
        /** @description Job id */
        job_id: string;
      };
    };
    responses: {
      /** @description Got job's error messages */
      200: {
        content: {
          "application/json": components["schemas"]["JobLogMessageCollection"];
        };
      };
    };
  };
  /**
   * Get a job's metrics 
   * @description Get a job's metrics
   */
  get_operator_metric_groups: {
    parameters: {
      path: {
        /** @description Pipeline id */
        pipeline_id: string;
        /** @description Job id */
        job_id: string;
      };
    };
    responses: {
      /** @description Got metric groups */
      200: {
        content: {
          "application/json": components["schemas"]["OperatorMetricGroupCollection"];
        };
      };
    };
  };
  /**
   * Subscribe to a job's output 
   * @description Subscribe to a job's output
   */
  get_job_output: {
    parameters: {
      path: {
        /** @description Pipeline id */
        pipeline_id: string;
        /** @description Job id */
        job_id: string;
      };
    };
    responses: {
      /** @description Job output as 'text/event-stream' */
      200: never;
    };
  };
  /**
   * Get Global UDFs 
   * @description Get Global UDFs
   */
  get_udfs: {
    responses: {
      /** @description List of UDFs */
      200: {
        content: {
          "application/json": components["schemas"]["GlobalUdfCollection"];
        };
      };
    };
  };
  /**
   * Create a global UDF 
   * @description Create a global UDF
   */
  create_udf: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UdfPost"];
      };
    };
    responses: {
      /** @description Created UDF */
      200: {
        content: {
          "application/json": components["schemas"]["Udf"];
        };
      };
    };
  };
  /**
   * Validate UDFs 
   * @description Validate UDFs
   */
  validate_udf: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ValidateUdfPost"];
      };
    };
    responses: {
      /** @description Validated query */
      200: {
        content: {
          "application/json": components["schemas"]["UdfValidationResult"];
        };
      };
    };
  };
  /**
   * Delete UDF 
   * @description Delete UDF
   */
  delete_udf: {
    parameters: {
      path: {
        /** @description UDF id */
        id: string;
      };
    };
    responses: {
      /** @description Deleted UDF */
      200: never;
    };
  };
}
