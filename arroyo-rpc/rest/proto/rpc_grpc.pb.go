// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: proto/rpc.proto

package arroyo_rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	ControllerGrpc_RegisterNode_FullMethodName            = "/arroyo_rpc.ControllerGrpc/RegisterNode"
	ControllerGrpc_HeartbeatNode_FullMethodName           = "/arroyo_rpc.ControllerGrpc/HeartbeatNode"
	ControllerGrpc_RegisterWorker_FullMethodName          = "/arroyo_rpc.ControllerGrpc/RegisterWorker"
	ControllerGrpc_Heartbeat_FullMethodName               = "/arroyo_rpc.ControllerGrpc/Heartbeat"
	ControllerGrpc_TaskStarted_FullMethodName             = "/arroyo_rpc.ControllerGrpc/TaskStarted"
	ControllerGrpc_TaskCheckpointEvent_FullMethodName     = "/arroyo_rpc.ControllerGrpc/TaskCheckpointEvent"
	ControllerGrpc_TaskCheckpointCompleted_FullMethodName = "/arroyo_rpc.ControllerGrpc/TaskCheckpointCompleted"
	ControllerGrpc_TaskFinished_FullMethodName            = "/arroyo_rpc.ControllerGrpc/TaskFinished"
	ControllerGrpc_TaskFailed_FullMethodName              = "/arroyo_rpc.ControllerGrpc/TaskFailed"
	ControllerGrpc_SendSinkData_FullMethodName            = "/arroyo_rpc.ControllerGrpc/SendSinkData"
	ControllerGrpc_WorkerFinished_FullMethodName          = "/arroyo_rpc.ControllerGrpc/WorkerFinished"
	ControllerGrpc_SubscribeToOutput_FullMethodName       = "/arroyo_rpc.ControllerGrpc/SubscribeToOutput"
	ControllerGrpc_WorkerError_FullMethodName             = "/arroyo_rpc.ControllerGrpc/WorkerError"
)

// ControllerGrpcClient is the client API for ControllerGrpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ControllerGrpcClient interface {
	RegisterNode(ctx context.Context, in *RegisterNodeReq, opts ...grpc.CallOption) (*RegisterNodeResp, error)
	HeartbeatNode(ctx context.Context, in *HeartbeatNodeReq, opts ...grpc.CallOption) (*HeartbeatNodeResp, error)
	RegisterWorker(ctx context.Context, in *RegisterWorkerReq, opts ...grpc.CallOption) (*RegisterWorkerResp, error)
	Heartbeat(ctx context.Context, in *HeartbeatReq, opts ...grpc.CallOption) (*HeartbeatResp, error)
	TaskStarted(ctx context.Context, in *TaskStartedReq, opts ...grpc.CallOption) (*TaskStartedResp, error)
	TaskCheckpointEvent(ctx context.Context, in *TaskCheckpointEventReq, opts ...grpc.CallOption) (*TaskCheckpointEventResp, error)
	TaskCheckpointCompleted(ctx context.Context, in *TaskCheckpointCompletedReq, opts ...grpc.CallOption) (*TaskCheckpointCompletedResp, error)
	TaskFinished(ctx context.Context, in *TaskFinishedReq, opts ...grpc.CallOption) (*TaskFinishedResp, error)
	TaskFailed(ctx context.Context, in *TaskFailedReq, opts ...grpc.CallOption) (*TaskFailedResp, error)
	SendSinkData(ctx context.Context, in *SinkDataReq, opts ...grpc.CallOption) (*SinkDataResp, error)
	// sent from the node to the controller when a worker process exits
	WorkerFinished(ctx context.Context, in *WorkerFinishedReq, opts ...grpc.CallOption) (*WorkerFinishedResp, error)
	SubscribeToOutput(ctx context.Context, in *GrpcOutputSubscription, opts ...grpc.CallOption) (ControllerGrpc_SubscribeToOutputClient, error)
	WorkerError(ctx context.Context, in *WorkerErrorReq, opts ...grpc.CallOption) (*WorkerErrorRes, error)
}

type controllerGrpcClient struct {
	cc grpc.ClientConnInterface
}

func NewControllerGrpcClient(cc grpc.ClientConnInterface) ControllerGrpcClient {
	return &controllerGrpcClient{cc}
}

func (c *controllerGrpcClient) RegisterNode(ctx context.Context, in *RegisterNodeReq, opts ...grpc.CallOption) (*RegisterNodeResp, error) {
	out := new(RegisterNodeResp)
	err := c.cc.Invoke(ctx, ControllerGrpc_RegisterNode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerGrpcClient) HeartbeatNode(ctx context.Context, in *HeartbeatNodeReq, opts ...grpc.CallOption) (*HeartbeatNodeResp, error) {
	out := new(HeartbeatNodeResp)
	err := c.cc.Invoke(ctx, ControllerGrpc_HeartbeatNode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerGrpcClient) RegisterWorker(ctx context.Context, in *RegisterWorkerReq, opts ...grpc.CallOption) (*RegisterWorkerResp, error) {
	out := new(RegisterWorkerResp)
	err := c.cc.Invoke(ctx, ControllerGrpc_RegisterWorker_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerGrpcClient) Heartbeat(ctx context.Context, in *HeartbeatReq, opts ...grpc.CallOption) (*HeartbeatResp, error) {
	out := new(HeartbeatResp)
	err := c.cc.Invoke(ctx, ControllerGrpc_Heartbeat_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerGrpcClient) TaskStarted(ctx context.Context, in *TaskStartedReq, opts ...grpc.CallOption) (*TaskStartedResp, error) {
	out := new(TaskStartedResp)
	err := c.cc.Invoke(ctx, ControllerGrpc_TaskStarted_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerGrpcClient) TaskCheckpointEvent(ctx context.Context, in *TaskCheckpointEventReq, opts ...grpc.CallOption) (*TaskCheckpointEventResp, error) {
	out := new(TaskCheckpointEventResp)
	err := c.cc.Invoke(ctx, ControllerGrpc_TaskCheckpointEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerGrpcClient) TaskCheckpointCompleted(ctx context.Context, in *TaskCheckpointCompletedReq, opts ...grpc.CallOption) (*TaskCheckpointCompletedResp, error) {
	out := new(TaskCheckpointCompletedResp)
	err := c.cc.Invoke(ctx, ControllerGrpc_TaskCheckpointCompleted_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerGrpcClient) TaskFinished(ctx context.Context, in *TaskFinishedReq, opts ...grpc.CallOption) (*TaskFinishedResp, error) {
	out := new(TaskFinishedResp)
	err := c.cc.Invoke(ctx, ControllerGrpc_TaskFinished_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerGrpcClient) TaskFailed(ctx context.Context, in *TaskFailedReq, opts ...grpc.CallOption) (*TaskFailedResp, error) {
	out := new(TaskFailedResp)
	err := c.cc.Invoke(ctx, ControllerGrpc_TaskFailed_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerGrpcClient) SendSinkData(ctx context.Context, in *SinkDataReq, opts ...grpc.CallOption) (*SinkDataResp, error) {
	out := new(SinkDataResp)
	err := c.cc.Invoke(ctx, ControllerGrpc_SendSinkData_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerGrpcClient) WorkerFinished(ctx context.Context, in *WorkerFinishedReq, opts ...grpc.CallOption) (*WorkerFinishedResp, error) {
	out := new(WorkerFinishedResp)
	err := c.cc.Invoke(ctx, ControllerGrpc_WorkerFinished_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerGrpcClient) SubscribeToOutput(ctx context.Context, in *GrpcOutputSubscription, opts ...grpc.CallOption) (ControllerGrpc_SubscribeToOutputClient, error) {
	stream, err := c.cc.NewStream(ctx, &ControllerGrpc_ServiceDesc.Streams[0], ControllerGrpc_SubscribeToOutput_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &controllerGrpcSubscribeToOutputClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ControllerGrpc_SubscribeToOutputClient interface {
	Recv() (*OutputData, error)
	grpc.ClientStream
}

type controllerGrpcSubscribeToOutputClient struct {
	grpc.ClientStream
}

func (x *controllerGrpcSubscribeToOutputClient) Recv() (*OutputData, error) {
	m := new(OutputData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controllerGrpcClient) WorkerError(ctx context.Context, in *WorkerErrorReq, opts ...grpc.CallOption) (*WorkerErrorRes, error) {
	out := new(WorkerErrorRes)
	err := c.cc.Invoke(ctx, ControllerGrpc_WorkerError_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ControllerGrpcServer is the server API for ControllerGrpc service.
// All implementations must embed UnimplementedControllerGrpcServer
// for forward compatibility
type ControllerGrpcServer interface {
	RegisterNode(context.Context, *RegisterNodeReq) (*RegisterNodeResp, error)
	HeartbeatNode(context.Context, *HeartbeatNodeReq) (*HeartbeatNodeResp, error)
	RegisterWorker(context.Context, *RegisterWorkerReq) (*RegisterWorkerResp, error)
	Heartbeat(context.Context, *HeartbeatReq) (*HeartbeatResp, error)
	TaskStarted(context.Context, *TaskStartedReq) (*TaskStartedResp, error)
	TaskCheckpointEvent(context.Context, *TaskCheckpointEventReq) (*TaskCheckpointEventResp, error)
	TaskCheckpointCompleted(context.Context, *TaskCheckpointCompletedReq) (*TaskCheckpointCompletedResp, error)
	TaskFinished(context.Context, *TaskFinishedReq) (*TaskFinishedResp, error)
	TaskFailed(context.Context, *TaskFailedReq) (*TaskFailedResp, error)
	SendSinkData(context.Context, *SinkDataReq) (*SinkDataResp, error)
	// sent from the node to the controller when a worker process exits
	WorkerFinished(context.Context, *WorkerFinishedReq) (*WorkerFinishedResp, error)
	SubscribeToOutput(*GrpcOutputSubscription, ControllerGrpc_SubscribeToOutputServer) error
	WorkerError(context.Context, *WorkerErrorReq) (*WorkerErrorRes, error)
	mustEmbedUnimplementedControllerGrpcServer()
}

// UnimplementedControllerGrpcServer must be embedded to have forward compatible implementations.
type UnimplementedControllerGrpcServer struct {
}

func (UnimplementedControllerGrpcServer) RegisterNode(context.Context, *RegisterNodeReq) (*RegisterNodeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterNode not implemented")
}
func (UnimplementedControllerGrpcServer) HeartbeatNode(context.Context, *HeartbeatNodeReq) (*HeartbeatNodeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HeartbeatNode not implemented")
}
func (UnimplementedControllerGrpcServer) RegisterWorker(context.Context, *RegisterWorkerReq) (*RegisterWorkerResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterWorker not implemented")
}
func (UnimplementedControllerGrpcServer) Heartbeat(context.Context, *HeartbeatReq) (*HeartbeatResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedControllerGrpcServer) TaskStarted(context.Context, *TaskStartedReq) (*TaskStartedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskStarted not implemented")
}
func (UnimplementedControllerGrpcServer) TaskCheckpointEvent(context.Context, *TaskCheckpointEventReq) (*TaskCheckpointEventResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskCheckpointEvent not implemented")
}
func (UnimplementedControllerGrpcServer) TaskCheckpointCompleted(context.Context, *TaskCheckpointCompletedReq) (*TaskCheckpointCompletedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskCheckpointCompleted not implemented")
}
func (UnimplementedControllerGrpcServer) TaskFinished(context.Context, *TaskFinishedReq) (*TaskFinishedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskFinished not implemented")
}
func (UnimplementedControllerGrpcServer) TaskFailed(context.Context, *TaskFailedReq) (*TaskFailedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskFailed not implemented")
}
func (UnimplementedControllerGrpcServer) SendSinkData(context.Context, *SinkDataReq) (*SinkDataResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendSinkData not implemented")
}
func (UnimplementedControllerGrpcServer) WorkerFinished(context.Context, *WorkerFinishedReq) (*WorkerFinishedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkerFinished not implemented")
}
func (UnimplementedControllerGrpcServer) SubscribeToOutput(*GrpcOutputSubscription, ControllerGrpc_SubscribeToOutputServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToOutput not implemented")
}
func (UnimplementedControllerGrpcServer) WorkerError(context.Context, *WorkerErrorReq) (*WorkerErrorRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkerError not implemented")
}
func (UnimplementedControllerGrpcServer) mustEmbedUnimplementedControllerGrpcServer() {}

// UnsafeControllerGrpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ControllerGrpcServer will
// result in compilation errors.
type UnsafeControllerGrpcServer interface {
	mustEmbedUnimplementedControllerGrpcServer()
}

func RegisterControllerGrpcServer(s grpc.ServiceRegistrar, srv ControllerGrpcServer) {
	s.RegisterService(&ControllerGrpc_ServiceDesc, srv)
}

func _ControllerGrpc_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterNodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerGrpcServer).RegisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerGrpc_RegisterNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerGrpcServer).RegisterNode(ctx, req.(*RegisterNodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerGrpc_HeartbeatNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatNodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerGrpcServer).HeartbeatNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerGrpc_HeartbeatNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerGrpcServer).HeartbeatNode(ctx, req.(*HeartbeatNodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerGrpc_RegisterWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterWorkerReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerGrpcServer).RegisterWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerGrpc_RegisterWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerGrpcServer).RegisterWorker(ctx, req.(*RegisterWorkerReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerGrpc_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerGrpcServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerGrpc_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerGrpcServer).Heartbeat(ctx, req.(*HeartbeatReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerGrpc_TaskStarted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskStartedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerGrpcServer).TaskStarted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerGrpc_TaskStarted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerGrpcServer).TaskStarted(ctx, req.(*TaskStartedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerGrpc_TaskCheckpointEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskCheckpointEventReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerGrpcServer).TaskCheckpointEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerGrpc_TaskCheckpointEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerGrpcServer).TaskCheckpointEvent(ctx, req.(*TaskCheckpointEventReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerGrpc_TaskCheckpointCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskCheckpointCompletedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerGrpcServer).TaskCheckpointCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerGrpc_TaskCheckpointCompleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerGrpcServer).TaskCheckpointCompleted(ctx, req.(*TaskCheckpointCompletedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerGrpc_TaskFinished_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskFinishedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerGrpcServer).TaskFinished(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerGrpc_TaskFinished_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerGrpcServer).TaskFinished(ctx, req.(*TaskFinishedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerGrpc_TaskFailed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskFailedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerGrpcServer).TaskFailed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerGrpc_TaskFailed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerGrpcServer).TaskFailed(ctx, req.(*TaskFailedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerGrpc_SendSinkData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SinkDataReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerGrpcServer).SendSinkData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerGrpc_SendSinkData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerGrpcServer).SendSinkData(ctx, req.(*SinkDataReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerGrpc_WorkerFinished_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerFinishedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerGrpcServer).WorkerFinished(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerGrpc_WorkerFinished_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerGrpcServer).WorkerFinished(ctx, req.(*WorkerFinishedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerGrpc_SubscribeToOutput_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GrpcOutputSubscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ControllerGrpcServer).SubscribeToOutput(m, &controllerGrpcSubscribeToOutputServer{stream})
}

type ControllerGrpc_SubscribeToOutputServer interface {
	Send(*OutputData) error
	grpc.ServerStream
}

type controllerGrpcSubscribeToOutputServer struct {
	grpc.ServerStream
}

func (x *controllerGrpcSubscribeToOutputServer) Send(m *OutputData) error {
	return x.ServerStream.SendMsg(m)
}

func _ControllerGrpc_WorkerError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerErrorReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerGrpcServer).WorkerError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerGrpc_WorkerError_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerGrpcServer).WorkerError(ctx, req.(*WorkerErrorReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ControllerGrpc_ServiceDesc is the grpc.ServiceDesc for ControllerGrpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ControllerGrpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arroyo_rpc.ControllerGrpc",
	HandlerType: (*ControllerGrpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterNode",
			Handler:    _ControllerGrpc_RegisterNode_Handler,
		},
		{
			MethodName: "HeartbeatNode",
			Handler:    _ControllerGrpc_HeartbeatNode_Handler,
		},
		{
			MethodName: "RegisterWorker",
			Handler:    _ControllerGrpc_RegisterWorker_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _ControllerGrpc_Heartbeat_Handler,
		},
		{
			MethodName: "TaskStarted",
			Handler:    _ControllerGrpc_TaskStarted_Handler,
		},
		{
			MethodName: "TaskCheckpointEvent",
			Handler:    _ControllerGrpc_TaskCheckpointEvent_Handler,
		},
		{
			MethodName: "TaskCheckpointCompleted",
			Handler:    _ControllerGrpc_TaskCheckpointCompleted_Handler,
		},
		{
			MethodName: "TaskFinished",
			Handler:    _ControllerGrpc_TaskFinished_Handler,
		},
		{
			MethodName: "TaskFailed",
			Handler:    _ControllerGrpc_TaskFailed_Handler,
		},
		{
			MethodName: "SendSinkData",
			Handler:    _ControllerGrpc_SendSinkData_Handler,
		},
		{
			MethodName: "WorkerFinished",
			Handler:    _ControllerGrpc_WorkerFinished_Handler,
		},
		{
			MethodName: "WorkerError",
			Handler:    _ControllerGrpc_WorkerError_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeToOutput",
			Handler:       _ControllerGrpc_SubscribeToOutput_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/rpc.proto",
}

const (
	WorkerGrpc_StartExecution_FullMethodName = "/arroyo_rpc.WorkerGrpc/StartExecution"
	WorkerGrpc_Checkpoint_FullMethodName     = "/arroyo_rpc.WorkerGrpc/Checkpoint"
	WorkerGrpc_StopExecution_FullMethodName  = "/arroyo_rpc.WorkerGrpc/StopExecution"
	WorkerGrpc_JobFinished_FullMethodName    = "/arroyo_rpc.WorkerGrpc/JobFinished"
)

// WorkerGrpcClient is the client API for WorkerGrpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkerGrpcClient interface {
	StartExecution(ctx context.Context, in *StartExecutionReq, opts ...grpc.CallOption) (*StartExecutionResp, error)
	Checkpoint(ctx context.Context, in *CheckpointReq, opts ...grpc.CallOption) (*CheckpointResp, error)
	StopExecution(ctx context.Context, in *StopExecutionReq, opts ...grpc.CallOption) (*StopExecutionResp, error)
	JobFinished(ctx context.Context, in *JobFinishedReq, opts ...grpc.CallOption) (*JobFinishedResp, error)
}

type workerGrpcClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkerGrpcClient(cc grpc.ClientConnInterface) WorkerGrpcClient {
	return &workerGrpcClient{cc}
}

func (c *workerGrpcClient) StartExecution(ctx context.Context, in *StartExecutionReq, opts ...grpc.CallOption) (*StartExecutionResp, error) {
	out := new(StartExecutionResp)
	err := c.cc.Invoke(ctx, WorkerGrpc_StartExecution_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerGrpcClient) Checkpoint(ctx context.Context, in *CheckpointReq, opts ...grpc.CallOption) (*CheckpointResp, error) {
	out := new(CheckpointResp)
	err := c.cc.Invoke(ctx, WorkerGrpc_Checkpoint_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerGrpcClient) StopExecution(ctx context.Context, in *StopExecutionReq, opts ...grpc.CallOption) (*StopExecutionResp, error) {
	out := new(StopExecutionResp)
	err := c.cc.Invoke(ctx, WorkerGrpc_StopExecution_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerGrpcClient) JobFinished(ctx context.Context, in *JobFinishedReq, opts ...grpc.CallOption) (*JobFinishedResp, error) {
	out := new(JobFinishedResp)
	err := c.cc.Invoke(ctx, WorkerGrpc_JobFinished_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerGrpcServer is the server API for WorkerGrpc service.
// All implementations must embed UnimplementedWorkerGrpcServer
// for forward compatibility
type WorkerGrpcServer interface {
	StartExecution(context.Context, *StartExecutionReq) (*StartExecutionResp, error)
	Checkpoint(context.Context, *CheckpointReq) (*CheckpointResp, error)
	StopExecution(context.Context, *StopExecutionReq) (*StopExecutionResp, error)
	JobFinished(context.Context, *JobFinishedReq) (*JobFinishedResp, error)
	mustEmbedUnimplementedWorkerGrpcServer()
}

// UnimplementedWorkerGrpcServer must be embedded to have forward compatible implementations.
type UnimplementedWorkerGrpcServer struct {
}

func (UnimplementedWorkerGrpcServer) StartExecution(context.Context, *StartExecutionReq) (*StartExecutionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartExecution not implemented")
}
func (UnimplementedWorkerGrpcServer) Checkpoint(context.Context, *CheckpointReq) (*CheckpointResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Checkpoint not implemented")
}
func (UnimplementedWorkerGrpcServer) StopExecution(context.Context, *StopExecutionReq) (*StopExecutionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopExecution not implemented")
}
func (UnimplementedWorkerGrpcServer) JobFinished(context.Context, *JobFinishedReq) (*JobFinishedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JobFinished not implemented")
}
func (UnimplementedWorkerGrpcServer) mustEmbedUnimplementedWorkerGrpcServer() {}

// UnsafeWorkerGrpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkerGrpcServer will
// result in compilation errors.
type UnsafeWorkerGrpcServer interface {
	mustEmbedUnimplementedWorkerGrpcServer()
}

func RegisterWorkerGrpcServer(s grpc.ServiceRegistrar, srv WorkerGrpcServer) {
	s.RegisterService(&WorkerGrpc_ServiceDesc, srv)
}

func _WorkerGrpc_StartExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartExecutionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerGrpcServer).StartExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerGrpc_StartExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerGrpcServer).StartExecution(ctx, req.(*StartExecutionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerGrpc_Checkpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckpointReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerGrpcServer).Checkpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerGrpc_Checkpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerGrpcServer).Checkpoint(ctx, req.(*CheckpointReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerGrpc_StopExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopExecutionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerGrpcServer).StopExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerGrpc_StopExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerGrpcServer).StopExecution(ctx, req.(*StopExecutionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerGrpc_JobFinished_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobFinishedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerGrpcServer).JobFinished(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerGrpc_JobFinished_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerGrpcServer).JobFinished(ctx, req.(*JobFinishedReq))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkerGrpc_ServiceDesc is the grpc.ServiceDesc for WorkerGrpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkerGrpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arroyo_rpc.WorkerGrpc",
	HandlerType: (*WorkerGrpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartExecution",
			Handler:    _WorkerGrpc_StartExecution_Handler,
		},
		{
			MethodName: "Checkpoint",
			Handler:    _WorkerGrpc_Checkpoint_Handler,
		},
		{
			MethodName: "StopExecution",
			Handler:    _WorkerGrpc_StopExecution_Handler,
		},
		{
			MethodName: "JobFinished",
			Handler:    _WorkerGrpc_JobFinished_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/rpc.proto",
}

const (
	NodeGrpc_StartWorker_FullMethodName = "/arroyo_rpc.NodeGrpc/StartWorker"
	NodeGrpc_GetWorkers_FullMethodName  = "/arroyo_rpc.NodeGrpc/GetWorkers"
	NodeGrpc_StopWorker_FullMethodName  = "/arroyo_rpc.NodeGrpc/StopWorker"
)

// NodeGrpcClient is the client API for NodeGrpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeGrpcClient interface {
	StartWorker(ctx context.Context, in *StartWorkerReq, opts ...grpc.CallOption) (*StartWorkerResp, error)
	GetWorkers(ctx context.Context, in *GetWorkersReq, opts ...grpc.CallOption) (*GetWorkersResp, error)
	StopWorker(ctx context.Context, in *StopWorkerReq, opts ...grpc.CallOption) (*StopWorkerResp, error)
}

type nodeGrpcClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeGrpcClient(cc grpc.ClientConnInterface) NodeGrpcClient {
	return &nodeGrpcClient{cc}
}

func (c *nodeGrpcClient) StartWorker(ctx context.Context, in *StartWorkerReq, opts ...grpc.CallOption) (*StartWorkerResp, error) {
	out := new(StartWorkerResp)
	err := c.cc.Invoke(ctx, NodeGrpc_StartWorker_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGrpcClient) GetWorkers(ctx context.Context, in *GetWorkersReq, opts ...grpc.CallOption) (*GetWorkersResp, error) {
	out := new(GetWorkersResp)
	err := c.cc.Invoke(ctx, NodeGrpc_GetWorkers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGrpcClient) StopWorker(ctx context.Context, in *StopWorkerReq, opts ...grpc.CallOption) (*StopWorkerResp, error) {
	out := new(StopWorkerResp)
	err := c.cc.Invoke(ctx, NodeGrpc_StopWorker_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeGrpcServer is the server API for NodeGrpc service.
// All implementations must embed UnimplementedNodeGrpcServer
// for forward compatibility
type NodeGrpcServer interface {
	StartWorker(context.Context, *StartWorkerReq) (*StartWorkerResp, error)
	GetWorkers(context.Context, *GetWorkersReq) (*GetWorkersResp, error)
	StopWorker(context.Context, *StopWorkerReq) (*StopWorkerResp, error)
	mustEmbedUnimplementedNodeGrpcServer()
}

// UnimplementedNodeGrpcServer must be embedded to have forward compatible implementations.
type UnimplementedNodeGrpcServer struct {
}

func (UnimplementedNodeGrpcServer) StartWorker(context.Context, *StartWorkerReq) (*StartWorkerResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWorker not implemented")
}
func (UnimplementedNodeGrpcServer) GetWorkers(context.Context, *GetWorkersReq) (*GetWorkersResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkers not implemented")
}
func (UnimplementedNodeGrpcServer) StopWorker(context.Context, *StopWorkerReq) (*StopWorkerResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopWorker not implemented")
}
func (UnimplementedNodeGrpcServer) mustEmbedUnimplementedNodeGrpcServer() {}

// UnsafeNodeGrpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeGrpcServer will
// result in compilation errors.
type UnsafeNodeGrpcServer interface {
	mustEmbedUnimplementedNodeGrpcServer()
}

func RegisterNodeGrpcServer(s grpc.ServiceRegistrar, srv NodeGrpcServer) {
	s.RegisterService(&NodeGrpc_ServiceDesc, srv)
}

func _NodeGrpc_StartWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWorkerReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGrpcServer).StartWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGrpc_StartWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGrpcServer).StartWorker(ctx, req.(*StartWorkerReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGrpc_GetWorkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGrpcServer).GetWorkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGrpc_GetWorkers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGrpcServer).GetWorkers(ctx, req.(*GetWorkersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGrpc_StopWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopWorkerReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGrpcServer).StopWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGrpc_StopWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGrpcServer).StopWorker(ctx, req.(*StopWorkerReq))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeGrpc_ServiceDesc is the grpc.ServiceDesc for NodeGrpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeGrpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arroyo_rpc.NodeGrpc",
	HandlerType: (*NodeGrpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartWorker",
			Handler:    _NodeGrpc_StartWorker_Handler,
		},
		{
			MethodName: "GetWorkers",
			Handler:    _NodeGrpc_GetWorkers_Handler,
		},
		{
			MethodName: "StopWorker",
			Handler:    _NodeGrpc_StopWorker_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/rpc.proto",
}

const (
	CompilerGrpc_CompileQuery_FullMethodName = "/arroyo_rpc.CompilerGrpc/CompileQuery"
)

// CompilerGrpcClient is the client API for CompilerGrpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CompilerGrpcClient interface {
	CompileQuery(ctx context.Context, in *CompileQueryReq, opts ...grpc.CallOption) (*CompileQueryResp, error)
}

type compilerGrpcClient struct {
	cc grpc.ClientConnInterface
}

func NewCompilerGrpcClient(cc grpc.ClientConnInterface) CompilerGrpcClient {
	return &compilerGrpcClient{cc}
}

func (c *compilerGrpcClient) CompileQuery(ctx context.Context, in *CompileQueryReq, opts ...grpc.CallOption) (*CompileQueryResp, error) {
	out := new(CompileQueryResp)
	err := c.cc.Invoke(ctx, CompilerGrpc_CompileQuery_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CompilerGrpcServer is the server API for CompilerGrpc service.
// All implementations must embed UnimplementedCompilerGrpcServer
// for forward compatibility
type CompilerGrpcServer interface {
	CompileQuery(context.Context, *CompileQueryReq) (*CompileQueryResp, error)
	mustEmbedUnimplementedCompilerGrpcServer()
}

// UnimplementedCompilerGrpcServer must be embedded to have forward compatible implementations.
type UnimplementedCompilerGrpcServer struct {
}

func (UnimplementedCompilerGrpcServer) CompileQuery(context.Context, *CompileQueryReq) (*CompileQueryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompileQuery not implemented")
}
func (UnimplementedCompilerGrpcServer) mustEmbedUnimplementedCompilerGrpcServer() {}

// UnsafeCompilerGrpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CompilerGrpcServer will
// result in compilation errors.
type UnsafeCompilerGrpcServer interface {
	mustEmbedUnimplementedCompilerGrpcServer()
}

func RegisterCompilerGrpcServer(s grpc.ServiceRegistrar, srv CompilerGrpcServer) {
	s.RegisterService(&CompilerGrpc_ServiceDesc, srv)
}

func _CompilerGrpc_CompileQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompileQueryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompilerGrpcServer).CompileQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CompilerGrpc_CompileQuery_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompilerGrpcServer).CompileQuery(ctx, req.(*CompileQueryReq))
	}
	return interceptor(ctx, in, info, handler)
}

// CompilerGrpc_ServiceDesc is the grpc.ServiceDesc for CompilerGrpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CompilerGrpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arroyo_rpc.CompilerGrpc",
	HandlerType: (*CompilerGrpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CompileQuery",
			Handler:    _CompilerGrpc_CompileQuery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/rpc.proto",
}
